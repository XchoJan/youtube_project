"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SliderIntro = SliderIntro;
exports.default = void 0;

var _react = _interopRequireWildcard(require("react"));

var _reactNative = require("react-native");

var _SkipButton = _interopRequireDefault(require("./SkipButton"));

var _NextButton = _interopRequireDefault(require("./NextButton"));

var _DoneButton = _interopRequireDefault(require("./DoneButton"));

var _NextContainer = _interopRequireDefault(require("./NextContainer"));

var _Item = _interopRequireDefault(require("./Item"));

var _PrevContainer = _interopRequireDefault(require("./PrevContainer"));

var _DotContainer = _interopRequireDefault(require("./DotContainer"));

var _StatusBarContainer = _interopRequireDefault(require("./StatusBarContainer"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

const setDefaultState = setSlide => {
  setSlide({
    active: 0,
    previous: 0,
    marginLeft: 0,
    dotMarginLeft: 0,
    expectOpacityOfNext: 1,
    expectOpacityOfDone: 0,
    expectOpacityOfSkip: 1,
    animations: {
      _moveSlideX: new _reactNative.Animated.Value(0),
      _moveSlideDotX: new _reactNative.Animated.Value(0),
      _moveSlideDotMarginX: new _reactNative.Animated.Value(0),
      _opacityOfNextButton: new _reactNative.Animated.Value(0),
      _opacityOfDoneButton: new _reactNative.Animated.Value(0),
      _opacityOfSkipButton: new _reactNative.Animated.Value(0)
    }
  });
};

const goToNewSlide = (newSlide, slide, setSlide, numberOfSlide, onDone, navContainerMaxSize, dotWidth, deviceMaxWidth) => {
  if (newSlide < 0) {
    return;
  }

  if (newSlide > numberOfSlide - 1) {
    setDefaultState(setSlide);
    onDone();
    return;
  }

  let expectOpacityOfNext = 0;
  let expectOpacityOfDone = 0;
  let expectOpacityOfSkip = 0;
  let expectedMarginLeft = 0;
  let expectedMarginLeftDot = newSlide * (navContainerMaxSize - numberOfSlide * dotWidth) / (numberOfSlide - 1) + newSlide * dotWidth;

  if (newSlide === numberOfSlide - 1) {
    expectOpacityOfNext = 0;
    expectOpacityOfDone = 1;
    expectOpacityOfSkip = 0;
  } else {
    expectOpacityOfNext = 1;
    expectOpacityOfDone = 0;
    expectOpacityOfSkip = 1;
  }

  const {
    active,
    marginLeft,
    animations
  } = slide;
  const {
    _moveSlideX,
    _moveSlideDotX,
    _moveSlideDotMarginX,
    _opacityOfNextButton,
    _opacityOfDoneButton,
    _opacityOfSkipButton
  } = animations;

  if (newSlide > active) {
    expectedMarginLeft = -(newSlide * deviceMaxWidth);
  } else if (newSlide < active) {
    expectedMarginLeft = -(newSlide * deviceMaxWidth);
  } else {
    expectedMarginLeft = marginLeft;
  }

  setSlide({
    active: newSlide,
    previous: active,
    dotMarginLeft: expectedMarginLeftDot,
    marginLeft: expectedMarginLeft,
    expectOpacityOfNext: expectOpacityOfNext,
    expectOpacityOfDone: expectOpacityOfDone,
    expectOpacityOfSkip: expectOpacityOfSkip,
    animations: {
      _moveSlideX: _moveSlideX,
      _moveSlideDotX: _moveSlideDotX,
      _moveSlideDotMarginX: _moveSlideDotMarginX,
      _opacityOfNextButton: _opacityOfNextButton,
      _opacityOfDoneButton: _opacityOfDoneButton,
      _opacityOfSkipButton: _opacityOfSkipButton
    }
  });
};

const _onGestureEvent = (translationX, slide, dotMaxPossibleWidth, deviceMaxWidth, dotWidth, slidesMaxWidth) => {
  const {
    marginLeft,
    dotMarginLeft,
    animations
  } = slide;
  const {
    _moveSlideX,
    _moveSlideDotX,
    _moveSlideDotMarginX
  } = animations;
  const newValue = translationX + marginLeft;
  const newDotWidthRawValue = dotMaxPossibleWidth / (deviceMaxWidth / translationX);
  const newDotWidthValue = translationX < 0 ? -1 * newDotWidthRawValue : newDotWidthRawValue;

  if (newValue > 0) {
    _moveSlideDotMarginX.setValue(dotMarginLeft);

    _moveSlideX.setValue(0);

    _moveSlideDotX.setValue(dotWidth);
  } else if (newValue < -slidesMaxWidth) {
    _moveSlideDotMarginX.setValue(dotMarginLeft);

    _moveSlideX.setValue(marginLeft);

    _moveSlideDotX.setValue(dotWidth);
  } else {
    _moveSlideX.setValue(newValue);

    if (newDotWidthValue <= dotWidth) {
      _moveSlideDotMarginX.setValue(dotMarginLeft);

      _moveSlideDotX.setValue(dotWidth);
    } else {
      if (translationX < 0) {
        _moveSlideDotMarginX.setValue(dotMarginLeft);
      } else {
        _moveSlideDotMarginX.setValue(dotMarginLeft - newDotWidthValue + dotWidth);
      }

      _moveSlideDotX.setValue(newDotWidthValue);
    }
  }
};

const _onHandlerStateChange = (translationX, slide, slidesMaxWidth, limitToSlide, setSlide, numberOfSlide, onDone, navContainerMaxSize, dotWidth, deviceMaxWidth) => {
  const {
    marginLeft,
    active
  } = slide;
  const newValue = translationX + marginLeft;

  if (newValue <= 0 && newValue >= -slidesMaxWidth) {
    let absoluteTranslation = 0;

    if (translationX < 0) {
      absoluteTranslation = translationX * -1;

      if (absoluteTranslation > limitToSlide) {
        goToNewSlide(active + 1, slide, setSlide, numberOfSlide, onDone, navContainerMaxSize, dotWidth, deviceMaxWidth);
      } else {
        goToNewSlide(active, slide, setSlide, numberOfSlide, onDone, navContainerMaxSize, dotWidth, deviceMaxWidth);
      }
    } else {
      absoluteTranslation = translationX;

      if (absoluteTranslation > limitToSlide) {
        goToNewSlide(active - 1, slide, setSlide, numberOfSlide, onDone, navContainerMaxSize, dotWidth, deviceMaxWidth);
      } else {
        goToNewSlide(active, slide, setSlide, numberOfSlide, onDone, navContainerMaxSize, dotWidth, deviceMaxWidth);
      }
    }
  }
};

const onBackPress = (backHandlerBehaviour, slide, setSlide, numberOfSlide, onDone, navContainerMaxSize, dotWidth, deviceMaxWidth) => {
  const {
    active,
    previous
  } = slide;
  backHandlerBehaviour === 'activeMinusOne' ? goToNewSlide(active - 1, slide, setSlide, numberOfSlide, onDone, navContainerMaxSize, dotWidth, deviceMaxWidth) : goToNewSlide(previous, slide, setSlide, numberOfSlide, onDone, navContainerMaxSize, dotWidth, deviceMaxWidth);
  return true;
};

const defaultProps = {
  data: [],
  renderItem: item => {
    const {
      index,
      title,
      text,
      image,
      backgroundColor,
      activeLanguage,
      link,
      slideMaxHeightPercent
    } = item;
    return /*#__PURE__*/_react.default.createElement(_Item.default, {
      key: index,
      index: index,
      title: title,
      text: text,
      image: image,
      backgroundColor: backgroundColor,
      activeLanguage: activeLanguage,
      link: link,
      slideMaxHeightPercent: slideMaxHeightPercent
    });
  },
  navigationBarBottom: 0,
  navigationBarHeight: 70,
  animateSlideSpeed: 15,
  navContainerMaxSizePercent: 0.5,
  dotWidth: 12,
  fixDotOpacity: 0.35,
  fixDotBackgroundColor: 'grey',
  animatedDotBackgroundColor: 'white',
  animateDotSpeed: 8,
  animateDotBouncing: 2,
  backHandlerBehaviour: 'activeMinusOne',
  hasReactNavigation: false,
  useCustomBackHandlerEffect: () => {},
  skipLabel: 'Skip',
  nextLabel: 'Next',
  doneLabel: 'Done',
  renderSkipButton: skipLabel => /*#__PURE__*/_react.default.createElement(_SkipButton.default, {
    skipLabel: skipLabel
  }),
  renderNextButton: nextLabel => /*#__PURE__*/_react.default.createElement(_NextButton.default, {
    nextLabel: nextLabel
  }),
  renderDoneButton: doneLabel => /*#__PURE__*/_react.default.createElement(_DoneButton.default, {
    doneLabel: doneLabel
  }),
  onDone: () => {},
  onSkip: () => {},
  showLeftButton: true,
  leftButtonType: 'skip',
  columnButtonStyle: false,
  showStatusBar: false,
  statusBarColor: '#febe29'
};

function SliderIntro({
  data,
  renderItem,
  navigationBarBottom,
  navigationBarHeight,
  animateSlideSpeed,
  navContainerMaxSizePercent,
  dotWidth,
  fixDotOpacity,
  fixDotBackgroundColor,
  animatedDotBackgroundColor,
  animateDotSpeed,
  animateDotBouncing,
  backHandlerBehaviour,
  hasReactNavigation,
  useCustomBackHandlerEffect,
  skipLabel,
  nextLabel,
  doneLabel,
  renderSkipButton,
  renderNextButton,
  renderDoneButton,
  onSkip,
  onDone,
  showLeftButton,
  leftButtonType,
  columnButtonStyle,
  showStatusBar,
  statusBarColor
}) {
  const [panResponder, setPanResponder] = (0, _react.useState)(_reactNative.PanResponder.create({}));
  const [slide, setSlide] = (0, _react.useState)({
    active: 0,
    previous: 0,
    marginLeft: 0,
    dotMarginLeft: 0,
    expectOpacityOfNext: 1,
    expectOpacityOfDone: 0,
    expectOpacityOfSkip: 1,
    animations: {
      _moveSlideX: new _reactNative.Animated.Value(0),
      _moveSlideDotX: new _reactNative.Animated.Value(0),
      _moveSlideDotMarginX: new _reactNative.Animated.Value(0),
      _opacityOfNextButton: new _reactNative.Animated.Value(0),
      _opacityOfDoneButton: new _reactNative.Animated.Value(0),
      _opacityOfSkipButton: new _reactNative.Animated.Value(0)
    }
  });
  const {
    length: numberOfSlide = 1
  } = data;
  const arrayOfSlideIndex = [...Array(numberOfSlide).keys()];

  const deviceMaxWidth = _reactNative.Dimensions.get('window').width;

  const limitToSlide = deviceMaxWidth * 0.5;
  const slidesMaxWidth = (numberOfSlide - 1) * deviceMaxWidth;
  const navContainerMaxSize = deviceMaxWidth * navContainerMaxSizePercent;
  const buttonsMaxSize = (deviceMaxWidth - navContainerMaxSize) / 2 - 1;
  const dotMaxPossibleWidth = navContainerMaxSize / (numberOfSlide - 1) + 9;
  const {
    active,
    marginLeft,
    animations,
    dotMarginLeft,
    expectOpacityOfNext,
    expectOpacityOfDone,
    expectOpacityOfSkip
  } = slide;
  const {
    _moveSlideX,
    _moveSlideDotX,
    _moveSlideDotMarginX,
    _opacityOfNextButton,
    _opacityOfDoneButton,
    _opacityOfSkipButton
  } = animations;
  const isLastSlide = active + 1 === numberOfSlide;
  (0, _react.useEffect)(() => {
    const panResponderItem = _reactNative.PanResponder.create({
      onStartShouldSetPanResponder: () => false,
      onMoveShouldSetPanResponder: (_, gestureState) => {
        return gestureState.dx != 0 && gestureState.dy != 0;
      },
      onMoveShouldSetPanResponderCapture: (_, gestureState) => {
        return gestureState.dx != 0 && gestureState.dy != 0;
      },
      onStartShouldSetPanResponderCapture: () => false,
      onPanResponderMove: (_, gesture) => {
        _onGestureEvent(gesture.dx, slide, dotMaxPossibleWidth, deviceMaxWidth, dotWidth, slidesMaxWidth);
      },
      onPanResponderRelease: (_, gesture) => {
        _onHandlerStateChange(gesture.dx, slide, slidesMaxWidth, limitToSlide, setSlide, numberOfSlide, onDone, navContainerMaxSize, dotWidth, deviceMaxWidth);
      }
    });

    setPanResponder(panResponderItem);

    const animateSlide = _reactNative.Animated.spring(_moveSlideX, {
      toValue: marginLeft,
      speed: animateSlideSpeed,
      bounciness: animateDotBouncing,
      useNativeDriver: false
    });

    const animateDotWidth = _reactNative.Animated.spring(_moveSlideDotX, {
      toValue: dotWidth,
      speed: animateDotSpeed,
      bounciness: animateDotBouncing,
      useNativeDriver: false
    });

    const animateDotMarginLeft = _reactNative.Animated.spring(_moveSlideDotMarginX, {
      toValue: dotMarginLeft,
      speed: animateDotSpeed,
      bounciness: animateDotBouncing,
      useNativeDriver: false
    });

    const animateOpacityOfNext = _reactNative.Animated.spring(_opacityOfNextButton, {
      toValue: expectOpacityOfNext,
      speed: animateDotSpeed,
      bounciness: animateDotBouncing,
      useNativeDriver: false
    });

    const animateOpacityOfDone = _reactNative.Animated.spring(_opacityOfDoneButton, {
      toValue: expectOpacityOfDone,
      speed: animateDotSpeed,
      bounciness: animateDotBouncing,
      useNativeDriver: false
    });

    const animateOpacityOfSkip = _reactNative.Animated.spring(_opacityOfSkipButton, {
      toValue: expectOpacityOfSkip,
      speed: animateDotSpeed,
      bounciness: animateDotBouncing,
      useNativeDriver: false
    });

    _reactNative.Animated.parallel([animateSlide, animateDotWidth, animateDotMarginLeft, animateOpacityOfNext, animateOpacityOfDone, animateOpacityOfSkip]).start();
  }, [slide]); // Based on React navigation lifecycle issue:
  // https://reactnavigation.org/docs/custom-android-back-button-handling/#why-not-use-component-lifecycle-methods

  if (hasReactNavigation) {
    useCustomBackHandlerEffect(active, onBackPress, backHandlerBehaviour, slide, setSlide, numberOfSlide, onDone, navContainerMaxSize, dotWidth, deviceMaxWidth);
  } else {
    (0, _react.useEffect)(() => {
      _reactNative.BackHandler.addEventListener('hardwareBackPress', () => onBackPress(backHandlerBehaviour, slide, setSlide, numberOfSlide, onDone, navContainerMaxSize, dotWidth, deviceMaxWidth));

      return () => _reactNative.BackHandler.removeEventListener('hardwareBackPress', () => onBackPress(backHandlerBehaviour, slide, setSlide, numberOfSlide, onDone, navContainerMaxSize, dotWidth, deviceMaxWidth));
    }, [active]);
  }

  return /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, showStatusBar && /*#__PURE__*/_react.default.createElement(_StatusBarContainer.default, {
    backgroundColor: statusBarColor
  }), /*#__PURE__*/_react.default.createElement(_reactNative.Animated.View, _extends({
    style: [styles.container, {
      maxWidth: numberOfSlide * deviceMaxWidth,
      marginLeft: _moveSlideX
    }]
  }, panResponder.panHandlers), data.map((item, index) => {
    return /*#__PURE__*/_react.default.createElement(_reactNative.View, {
      key: index,
      style: {
        width: deviceMaxWidth
      }
    }, renderItem(item));
  })), /*#__PURE__*/_react.default.createElement(_reactNative.View, {
    style: [styles.navContainer, {
      bottom: navigationBarBottom,
      height: navigationBarHeight,
      maxHeight: navigationBarHeight
    }]
  }, /*#__PURE__*/_react.default.createElement(_reactNative.View, {
    style: [styles.navigation, {
      flexDirection: columnButtonStyle ? 'column' : 'row'
    }]
  }, columnButtonStyle ? /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/_react.default.createElement(_DotContainer.default, {
    navContainerMaxSize: navContainerMaxSize,
    arrayOfSlideIndex: arrayOfSlideIndex,
    fixDotBackgroundColor: fixDotBackgroundColor,
    fixDotOpacity: fixDotOpacity,
    dotWidth: dotWidth,
    _moveSlideDotX: _moveSlideDotX,
    _moveSlideDotMarginX: _moveSlideDotMarginX,
    animatedDotBackgroundColor: animatedDotBackgroundColor
  }), /*#__PURE__*/_react.default.createElement(_NextContainer.default, {
    goToNewSlide: goToNewSlide,
    slide: slide,
    setSlide: setSlide,
    numberOfSlide: numberOfSlide,
    onDone: onDone,
    navContainerMaxSize: navContainerMaxSize,
    dotWidth: dotWidth,
    deviceMaxWidth: deviceMaxWidth,
    renderNextButton: () => renderNextButton(nextLabel),
    renderDoneButton: () => renderDoneButton(doneLabel),
    isLastSlide: isLastSlide,
    buttonsMaxSize: buttonsMaxSize
  }), /*#__PURE__*/_react.default.createElement(_PrevContainer.default, {
    setDefaultState: () => setDefaultState(setSlide),
    onSkip: onSkip,
    buttonsMaxSize: buttonsMaxSize,
    _opacityOfSkipButton: _opacityOfSkipButton,
    renderSkipButton: () => renderSkipButton(skipLabel),
    type: leftButtonType,
    goToNewSlide: goToNewSlide,
    slide: slide,
    setSlide: setSlide,
    numberOfSlide: numberOfSlide,
    onDone: onDone,
    navContainerMaxSize: navContainerMaxSize,
    dotWidth: dotWidth,
    deviceMaxWidth: deviceMaxWidth,
    showLeftButton: showLeftButton
  })) : /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/_react.default.createElement(_PrevContainer.default, {
    setDefaultState: () => setDefaultState(setSlide),
    onSkip: onSkip,
    buttonsMaxSize: buttonsMaxSize,
    _opacityOfSkipButton: _opacityOfSkipButton,
    renderSkipButton: () => renderSkipButton(skipLabel),
    type: leftButtonType,
    goToNewSlide: goToNewSlide,
    slide: slide,
    setSlide: setSlide,
    numberOfSlide: numberOfSlide,
    onDone: onDone,
    navContainerMaxSize: navContainerMaxSize,
    dotWidth: dotWidth,
    deviceMaxWidth: deviceMaxWidth,
    showLeftButton: showLeftButton
  }), /*#__PURE__*/_react.default.createElement(_DotContainer.default, {
    navContainerMaxSize: navContainerMaxSize,
    arrayOfSlideIndex: arrayOfSlideIndex,
    fixDotBackgroundColor: fixDotBackgroundColor,
    fixDotOpacity: fixDotOpacity,
    dotWidth: dotWidth,
    _moveSlideDotX: _moveSlideDotX,
    _moveSlideDotMarginX: _moveSlideDotMarginX,
    animatedDotBackgroundColor: animatedDotBackgroundColor
  }), /*#__PURE__*/_react.default.createElement(_NextContainer.default, {
    goToNewSlide: goToNewSlide,
    slide: slide,
    setSlide: setSlide,
    numberOfSlide: numberOfSlide,
    onDone: onDone,
    navContainerMaxSize: navContainerMaxSize,
    dotWidth: dotWidth,
    deviceMaxWidth: deviceMaxWidth,
    renderNextButton: () => renderNextButton(nextLabel),
    renderDoneButton: () => renderDoneButton(doneLabel),
    isLastSlide: isLastSlide,
    buttonsMaxSize: buttonsMaxSize
  })))));
}

SliderIntro.defaultProps = defaultProps;

const styles = _reactNative.StyleSheet.create({
  container: {
    flex: 1,
    flexDirection: 'row'
  },
  navContainer: {
    position: 'absolute',
    width: '100%',
    maxWidth: '100%',
    flex: 1,
    flexDirection: 'column',
    justifyContent: 'flex-end',
    alignItems: 'center'
  },
  navigation: {
    flex: 1,
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center'
  },
  prevContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center'
  },
  prevButton: {
    flex: 1,
    flexDirection: 'row',
    alignItems: 'center'
  },
  prevText: {
    textTransform: 'uppercase',
    fontWeight: 'bold',
    color: 'white',
    fontSize: 14
  }
});

var _default = SliderIntro;
exports.default = _default;
//# sourceMappingURL=SliderIntro.js.map